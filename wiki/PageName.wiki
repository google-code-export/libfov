= libfov =

== About ==

libfov is a C library for calculating fields of view and lighting on low resolution rasters, suitable for roguelike games. In that screenshot below, imagine that green dot is your character in a computer game, and as you walk around (move between tiles on the grid), you want to know which tiles you can see and which tiles you cannot. libfov calculates exactly that.

It can also be used to calculate which tiles are lit from a light source (the fov source doesn't have to be your eyesight, it can be a lightbulb). libfov supports beams, so you can use it to do nice directed lighting effects such as torch/flashlight lights.

libfov is fairly flexible in its design. It does not impose a map data structure on you. It operates via a couple of callbacks. It leaves enough room for you to decide what you want to do with the algorithm. You could conceivably use it in a real-time grid-based game with flickering multicoloured torches hanging off the walls, or you could use it behind the scenes to decide that a monster can see you, without displaying it on the screen.

== Screenshots ==

[http://libfov.sourceforge.net/wiki/images/1/1d/Libfov-1.png]

== License ==

[http://www.opensource.org/licenses/mit-license.php MIT license]

== Getting libfov ==

=== Source ===

http://sourceforge.net/projects/libfov

{{{
./configure && make
}}}

From here, you can 'make install' to make libfov available on your system globally, or you can link against libfov.a or fov.o. It won't increase your binary size much (it's a tiny C library) and doing so reduces your runtime dependencies. Using 'make install' plus static linking is probably easiest.

=== FreeBSD/Ports ===

  * [http://www.freebsdports.info/ports/games/libfov.html]
  * [http://www.freshports.org/games/libfov]

== Using libfov ==

  * [http://libfov.sourceforge.net/api API]

== Projects Using libfov ==

  * [http://www.netikka.net/joyr/obdur/index.html Opdur]

== FAQ ==

=== What are these strange {{{void *map}}} and {{{void *source}}} I keep seeing? ===

{{{void *map}}} is a pointer to your map data. In C, this should be an instance of a C struct you define. In C++, this can be an object.

{{{void *source}}} is a pointer to information about the light source. Again, in C, this should be an instance of a C struct you define. In C++, this can be an object. For instance, the light source might hold information about the colour or strength or intensity of the light. You need to know this information in your "apply" callback if you want to do several fancy types of lighting such as coloured lights, flickering torches or variable intensity lights.

These pointers are not used by the library itself, except to pass back to your callback functions so that you can use the information to decide whether a particular tile is opaque and how to apply lighting to it. You should define your own map data structure.

If you do not care about light sources because you are using libfov to calculate line-of-sight or because you want very simple lighting, you can pass NULL as the source pointer.

=== Are the 'map data structure' and 'source data structure' structs? Where are they defined? ===

You define these yourself, pass them into any libfov functions that ask for them, and libfov will make sure it passes them back to you when it knows you'll need them - i.e. in your callbacks. This mechanism, although slightly tricky at first,
  * avoids nasty global variables and
  * gives you the liberty of defining your own data structures to suit your own needs.

=== The example (simple.cc) seems to give libfov instances of C++ classes... but how can a C lib accept a C++ class? ===

You're right, you can't pass a C++ object to a C library but you _can_ pass a pointer to a C++ object to a C library as long as that C library does not know about the C++ class (i.e. uses void rather than a class), does not try to dereference the pointer, cast the pointer, or do anything with the data being pointed to. In that case, the pointer is just like an integer. In libfov's case, the pointer is never dereferenced, just passed straight back to your callback, which itself can then cast to a C structure or C++ object pointer (because you're back in your own territory where you know what data type that pointer should be).

=== Can we please have a Visual C++ example? ===

I do not own a copy of Visual C++, but I am happy to accept any contributions of a Visual C++ project file and a Visual C++ example. I will commit them to libfov's source distribution so people running Visual C++ can get started quicker.

In the long run, I would like to get Visual C++ running in a virtual machine, so I can properly support it, but that's some way off so don't hold your breath.